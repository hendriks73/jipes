/*
 * =================================================
 * Copyright 2011 tagtraum industries incorporated
 * All rights reserved.
 * =================================================
 */
package com.tagtraum.jipes.audio;

import javax.sound.sampled.AudioFormat;
import java.util.Arrays;

/**
 * <p>Represents a spectrum with linear frequencies (as opposed to a {@link LogFrequencySpectrum})
 * as generated by a suitable {@link com.tagtraum.jipes.SignalProcessor}.
 * </p><p>
 * Even though instances are meant to be immutable, all methods return
 * the original, internally used arrays to increase efficiency and reduce
 * memory consumption. As a consequence you <em>must never</em> modify any
 * of those arrays returned to you.
 * </p>
 *
 * @author <a href="mailto:hs@tagtraum.com">Hendrik Schreiber</a>
 */
public class LinearFrequencySpectrum extends AbstractAudioSpectrum implements Cloneable {

    private static final double LOG2 = Math.log(2.0);
    private float[] frequencies;

    public LinearFrequencySpectrum(final int frameNumber, final float[] realData, final float[] imaginaryData, final AudioFormat audioFormat) {
        super(frameNumber, realData, imaginaryData, audioFormat);
    }

    public LinearFrequencySpectrum(final LinearFrequencySpectrum linearFrequencySpectrum) {
        super(linearFrequencySpectrum);
    }

    @Override
    public void reuse(final int frameNumber, final float[] realData, final float[] imaginaryData, final AudioFormat audioFormat) {
        super.reuse(frameNumber, realData, imaginaryData, audioFormat);
        this.frequencies = null;
    }

    /**
     * Returns the bandwidth (or frequency resolution) of this buffer. This the distance from one bin to the next in Hz or
     * in other words, the width of one bin in Hz.
     *
     * @return frequency resolution in Hz
     */
    public float getBandwidth() {
        return getAudioFormat().getSampleRate() / getRealData().length;
    }

    /**
     * Computes the deviation of the frequency at index <code>i</code> from a standard semitone in cents.
     *
     * @return array of deviations from a semitone in cents [-49,50] for each index.
     */
    public int[] getDeviationsInCents() {
        return getDeviationInSemitoneFractions(100);
    }

    /**
     * Computes the deviation of the frequency at index <code>i</code> from a standard semitone in fractions of this semitone.
     *
     * @param resolution number of possible fractions. E.g. 100 for cents resolution
     * @return array of deviations from a semitone in fractions of a semitone for each index.
     */
    public int[] getDeviationInSemitoneFractions(final int resolution) {
        final float[] frequencies = this.getFrequencies();
        final int[] deviationsInFractions = new int[frequencies.length];
        for (int i=0; i<frequencies.length; i++) {
            deviationsInFractions[i] = roundDeviation(deviationFromStandardTuningInSemitoneFractions(frequencies[i], resolution), resolution);
        }
        return deviationsInFractions;
    }

    /**
     * Computes the deviation from standard 440Hz tuning in cents. The given
     * frequency does not have to be an A4.
     *
     * @param frequency frequency in Hz
     * @return deviation from standard tuning in cents - value between <code>-49</code> and <code>50</code>
     * @see #deviationFromStandardTuningInSemitoneFractions(double, int)
     */
    private static float deviationFromStandardTuningInCents(final double frequency) {
        return deviationFromStandardTuningInSemitoneFractions(frequency, 100);
    }

    /**
     * Computes the deviation from standard 440Hz tuning in fractions of a semitone. The given
     * frequency does not have to be an A4.
     *
     * @param frequency frequency in Hz
     * @param resolution to get cents, this needs to be <code>100</code>, to get thirds, this needs to be <code>3</code>
     * @return deviation from standard tuning in fractions - e.g. for a resolution of <code>100</code> this returns a value between <code>-49</code> and <code>50</code>.
     * For a resolution of <code>3</code>, this returns a value between <code>-1</code> and <code>+1</code>.
     */
    private static float deviationFromStandardTuningInSemitoneFractions(final double frequency, final int resolution) {
        final double absolute = resolution * 12d * log2(frequency/440d);
        final float relative = (float)(absolute % resolution);
        final float fractions;
        if (relative > resolution/2d) fractions = relative - resolution;
        else if (relative <= resolution/-2d) fractions = relative + resolution;
        else fractions = relative;
        return fractions;
    }


    private static int roundDeviation(final float value, final int resolution) {
        final int rounded = Math.round(value);
        if (rounded < -(resolution-1)/2) {
            return rounded + (resolution);
        } else {
            return rounded;
        }
    }

    /**
     * Array with frequency values in Hz corresponding to the bin numbers.
     *
     * @return array of length <code>numberOfSamples/2</code> due to symmetry
     * @see #getFrequency(int)
     */
    public synchronized float[] getFrequencies() {
        if (frequencies == null) {
            frequencies = computeFrequencies();
        }
        return frequencies;
    }

    protected float[] computeFrequencies() {
        final float[] frequencies = new float[getRealData().length/2];
        for (int i=0; i<frequencies.length; i++) {
            frequencies[i] = getFrequency(i);
        }
        return frequencies;
    }

    /**
     * Returns the frequency of a given bin. If you need the frequencies for the whole
     * spectrum you might rather use {@link #getFrequencies()}, as it is more efficient.
     *
     * @param bin bin number
     * @return frequency in Hz
     * @see #getFrequencies()
     */
    @Override
    public float getFrequency(final int bin) {
        final int numSamples = getRealData().length;
        if (bin >= numSamples || bin < 0) {
            return 0.0f;
        } else if (bin <= numSamples / 2) {
            return (bin / (float)numSamples) * getAudioFormat().getSampleRate();
        } else {
            return ((numSamples - bin) / (float)numSamples) * getAudioFormat().getSampleRate();
        }
    }

    /**
     * Computes a bin/index for the given frequency.
     *
     * @param frequency frequency
     * @return bin
     */
    public int getBin(final float frequency) {
        return (int) ((frequency / getAudioFormat().getSampleRate()) * getRealData().length);
    }

    /*
    public static MapFunction<FourierAudioSpectrum> POWER_CEPSTRUM = new MapFunction<FourierAudioSpectrum>() {
        public FourierAudioSpectrum map(final FourierAudioSpectrum spectrum) {
            return spectrum.getPowerCepstrum();
        }

        @Override
        public String toString() {
            return "POWER_CEPSTRUM";
        }
    };

    public static MapFunction<FourierAudioSpectrum> MAGNITUDE_CEPSTRUM = new MapFunction<FourierAudioSpectrum>() {
        public FourierAudioSpectrum map(final FourierAudioSpectrum spectrum) {
            return spectrum.getMagnitudeCepstrum();
        }

        @Override
        public String toString() {
            return "MAGNITUDE_CEPSTRUM";
        }
    };

    public FourierAudioSpectrum getPowerCepstrum() {
        return getRealCepstrum(computeFullPowers());
    }

    public FourierAudioSpectrum getMagnitudeCepstrum() {
        return getRealCepstrum(computeFullMagnitudes());
    }

    private FourierAudioSpectrum getRealCepstrum(final float[] amplitude) {
        final float[] logs = Floats.log(amplitude);
        final FFT fft = FFT.newInstance();
        final float[][] floats = fft.transform(logs.length, logs);
        return new FourierAudioSpectrum(floats[0], floats[1], audioFormat);
    }
    */

    /**
     * Powers (sum of the squares of the real and imaginary part) of the spectrum.
     *
     * @return array of length numberOfSamples/2 due to symmetry
     * @see #getMagnitudes()
     */
    public synchronized float[] getPowers() {
        if (powers == null) {
            powers = computePowers(getNumberOfSamples() / 2);
        }
        return powers;
    }

    /**
     * Magnitudes (square root of the powers) of the spectrum.
     *
     * @return array of length numberOfSamples/2 due to symmetry
     * @see #getPowers()
     */
    public synchronized float[] getMagnitudes() {
        if (magnitudes == null) {
            magnitudes = computeMagnitudes(getNumberOfSamples() / 2, powers);
        }
        return magnitudes;
    }

    public LinearFrequencySpectrum derive(final float[] real, final float[] imaginary) {
        return new LinearFrequencySpectrum(getFrameNumber(), real, imaginary, getAudioFormat());
    }

    /**
     * Base 2 logarithm.
     *
     * @param n n
     * @return base 2 logarithm
     */
    private static double log2(final double n) {
        return Math.log(n) / LOG2;
    }


    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        LinearFrequencySpectrum that = (LinearFrequencySpectrum) o;

        if (this.frameNumber != that.frameNumber) return false;
        if (getAudioFormat() != null ? !getAudioFormat().equals(that.getAudioFormat()) : that.getAudioFormat() != null) return false;
        if (!Arrays.equals(getImaginaryData(), that.getImaginaryData())) return false;
        if (!Arrays.equals(getRealData(), that.getRealData())) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = getAudioFormat() != null ? getAudioFormat().hashCode() : 0;
        result = 31 * result + (getRealData() != null ? Arrays.hashCode(getRealData()) : 0);
        result = 31 * result + frameNumber;
        return result;
    }

    @Override
    public String toString() {
        return "LinearFrequencySpectrum{" +
                "audioFormat=" + getAudioFormat() +
                ", numberOfSamples=" + getNumberOfSamples() +
                ", timestamp=" + getTimestamp() +
                ", frameNumber=" + getFrameNumber() +
                ", realData=" + getRealData() +
                ", imaginaryData=" + getImaginaryData() +
                '}';
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        final LinearFrequencySpectrum clone = (LinearFrequencySpectrum)super.clone();
        if (this.frequencies != null) clone.frequencies = this.frequencies.clone();
        return clone;
    }
}

